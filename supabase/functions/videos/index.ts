import { createClient } from "supabase";

import { verifyClerkToken } from "../_shared/clerk-auth.ts";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;


const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);



const allowedOrigins = [
  "http://localhost:5173",
  "https://vidifolio.vercel.app"
];

type VisualStyle = 'standard tech' | 'cyberpunk' | 'nature clean';

// Helper to wait
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));







async function processVideoGeneration(
  supabase: any,
  videoRecord: any,
  portfolio: any,
  visualStyle: VisualStyle
) {
  try {
    const videoId = videoRecord.id;
    console.log(`[Mock] Starting mock generation for video ${videoId}`);

    // Simulate processing time (15 seconds)
    console.log(`[Mock] Waiting 15 seconds to simulate generation...`);
    await sleep(15000);

    // Mock Video URL (Public Sample Video)
    const mockVideoUrl = "https://illueaemdsirgpbjzwlz.supabase.co/storage/v1/object/public/videos/3e8c8c79-4cc3-41e2-80e1-46d751d7271c/Feb_07__0449_21s_202602070505_6f1kp.mp4";

    console.log(`[Mock] Finishing generation with sample URL: ${mockVideoUrl}`);

    // Update DB as COMPLETED
    const { error: updateError } = await supabase.from("videos").update({
        status: "COMPLETED",
        video_url: mockVideoUrl,
        ai_metadata: { 
            ...videoRecord.ai_metadata,
            mock: true,
            note: "Generated by Mock Function (No API Cost)",
            segments: [
                { step: 1, status: "completed", mock: true },
                { step: 2, status: "completed", mock: true },
                { step: 3, status: "completed", mock: true }
            ]
        }
    }).eq("id", videoId);

    if (updateError) {
        console.error(`[Mock] DB update failed:`, updateError);
        throw updateError;
    }

    console.log(`[Mock] Successfully finalized video ${videoId}`);

  } catch (error: any) {
    console.error(`[Mock] Generation Failed for ${videoRecord.id}:`, error);
    await supabase.from("videos").update({ 
        status: "FAILED",
        ai_metadata: {
            ...videoRecord.ai_metadata,
            error: error.message
        }
    }).eq("id", videoRecord.id);
  }
}

Deno.serve(async (req) => {
  const origin = req.headers.get("origin");
  const method = req.method;
  const url = new URL(req.url);
  console.log(`>>>> [Videos] Incoming ${method} request to ${url.pathname}`);

  const corsHeaders: Record<string, string> = {
    "Access-Control-Allow-Methods": "GET, POST, PATCH, OPTIONS",
    "Access-Control-Allow-Headers": "Authorization, Content-Type, apikey, x-client-info",
    "Access-Control-Allow-Credentials": "true",
  };

  if (origin && allowedOrigins.includes(origin)) {
    corsHeaders["Access-Control-Allow-Origin"] = origin;
  }

  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const payload = await verifyClerkToken(req);
    const clerkId = payload.sub as string;
    console.log(`[Videos] Authenticated Clerk User: ${clerkId}`);

    const { data: user, error: userError } = await supabase
      .from("users")
      .select("id")
      .eq("clerk_id", clerkId)
      .single();

    if (userError || !user) {
      console.error(`[Videos] User lookup failed for clerkId ${clerkId}:`, userError);
      throw new Error("User not found.");
    }

    const userId = user.id;
    const pathSegments = url.pathname.split("/").filter(Boolean);

    // Handle POST /videos/generate
    if (req.method === "POST" && pathSegments.includes("generate")) {
      const { portfolio_id, visual_style } = await req.json();
      console.log(`[Videos] Starting generation for portfolio: ${portfolio_id}, Style: ${visual_style}`);

      if (!portfolio_id || !visual_style) {
        throw new Error("portfolio_id and visual_style are required.");
      }

      // 1. Fetch portfolio data
      console.log(`[Videos] Fetching portfolio data for ID: ${portfolio_id}`);
      const { data: portfolio, error: portError } = await supabase
        .from("portfolios")
        .select("*")
        .eq("id", portfolio_id)
        .eq("user_id", userId)
        .single();

      if (portError || !portfolio) {
        console.error(`[Videos] Portfolio fetch error:`, portError);
        throw new Error("Portfolio not found or unauthorized.");
      }

      // 2. Create initial record IMMEDIATELY with PROCESSING status
      console.log(`[Videos] Creating initial database record...`);
      const { data: videoRecord, error: initError } = await supabase
        .from("videos")
        .insert({
          user_id: userId,
          portfolio_id: portfolio_id,
          status: "PROCESSING",
          ai_metadata: { 
            model: "veo-3.1-fast-generate-preview", 
            visual_style, 
            segments: [], 
            extension_count: 0 
          },
        })
        .select()
        .single();

      if (initError) {
        console.error(`[Videos] Initial DB insert failed:`, initError);
        throw initError;
      }

      // 3. Start Background Processing using EdgeRuntime.waitUntil
      // This allows the function to return the response while the async task continues.
      console.log(`[Videos] Scheduling background generation task for ${videoRecord.id}...`);
      
      EdgeRuntime.waitUntil(
        processVideoGeneration(supabase, videoRecord, portfolio, visual_style as VisualStyle)
      );

      // 4. Return immediately
      console.log(`[Videos] Returning initial response to client.`);
      return new Response(JSON.stringify(videoRecord), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 201, // Created
      });
    }

    // Handle GET /videos/{id}
    if (req.method === "GET") {
      const videoId = url.searchParams.get("id") || pathSegments[pathSegments.length - 1];
      console.log(`[Videos] Fetching video record: ${videoId}`);

      if (!videoId || videoId === "videos") throw new Error("Video ID is required.");
  
      const { data: video, error } = await supabase
          .from("videos")
          .select("*")
          .eq("id", videoId)
          .eq("user_id", userId)
          .single();

      if (error || !video) {
          console.warn(`[Videos] Video ${videoId} not found or unauthorized for user ${userId}`);
          return new Response(JSON.stringify({ error: "Video not found or unauthorized" }), {
              headers: { ...corsHeaders, "Content-Type": "application/json" },
              status: 404,
          });
      }

      return new Response(JSON.stringify(video), {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
          status: 200,
      });
    }

    // Handle PATCH /videos/{id}/edit
    if (req.method === "PATCH") {
      const videoId = pathSegments[pathSegments.length - 1];
      console.log(`[Videos] Updating video record: ${videoId}`);
      if (!videoId || videoId === "videos") throw new Error("Video ID is required.");

      const updates = await req.json();
      const { data, error } = await supabase
        .from("videos")
        .update(updates)
        .eq("id", videoId)
        .eq("user_id", userId)
        .select()
        .single();

      if (error) {
        console.error(`[Videos] Patch update failed for ${videoId}:`, error);
        throw error;
      }

      return new Response(JSON.stringify(data), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      });
    }

    return new Response("Method or Path not allowed", { status: 405 });
  } catch (error) {
    console.error("[Videos] Global Catch Error:", error.message);
    return new Response(JSON.stringify({ error: error.message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 400,
    });
  }
});
